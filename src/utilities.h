/// Causal Dynamical Triangulations in C++ using CGAL
///
/// Copyright (c) 2013 Adam Getchell
///
/// Utility functions for cdt.cpp

/// \done <a href="http://www.cprogramming.com/tutorial/const_correctness.html">
/// Const Correctness</a>
/// \done Use localtime_r() for thread safety

/// @file utilities.h
/// @brief Utility functions
/// @author Adam Getchell
/// @bug <a href="http://clang-analyzer.llvm.org/scan-build.html">
/// scan-build</a>: No bugs found.

#ifndef SRC_UTILITIES_H_
#define SRC_UTILITIES_H_

// CGAL headers
#include <CGAL/Gmpzf.h>
#include <CGAL/Timer.h>

// C headers
#include <sys/utsname.h>

// C++ headers
#include <stdexcept>
#include <iostream>
#include <fstream>
#include <string>
#include <random>
#include <mutex>

// Boost
// #include <boost/type_index.hpp>

using Gmpzf = CGAL::Gmpzf;

enum class topology_type { TOROIDAL, SPHERICAL};

/// @brief Return an environment variable
///
/// Uses **getenv** from **/<cstdlib/>** which has a char* rvalue
///
/// @param[in] key The string value
/// @returns The environment variable corresponding to the key as a std::string
inline auto getEnvVar(std::string const& key) noexcept {
  char const* val = getenv(key.c_str());
  return val == NULL ? std::string() : std::string(val);
}

/// @brief Return the hostname
///
/// **auto** doesn't work here as a return type because **name.nodename** is a
/// stack memory address.
///
/// @returns The hostname as a std::string
inline std::string hostname() noexcept {
  struct utsname name;
  // Ensure uname returns a value
  if (uname(&name)) exit(-1);
  return name.nodename;
}

/// @brief Return the current date and time
///
/// **Auto** doesn't work here as a return type because **time_str** is a
/// stack memory address.
///
/// @returns The current data and time in a thread-safe manner using
/// **localtime_r()** as a std::string.
inline const std::string currentDateTime() noexcept {
  auto now = time(0);
  struct tm tstruct;
  char time_str[100];
  localtime_r(&now, &tstruct);
  // Visit http://en.cppreference.com/w/cpp/chrono/c/strftime
  // for more info about date/time format
  strftime(time_str, sizeof(time_str), "%Y-%m-%d.%X%Z", &tstruct);

  return time_str;
}

/// @brief Generate useful filenames
///
/// @param[in] top The topology type from the scoped enum topology_type
/// @param[in] dimensions The number of dimensions of the triangulation
/// @param[in] number_of_simplices The number of simplices in the triangulation
/// @param[in] number_of_timeslices The number of foliated timeslices
/// @returns A filename as a std::string
inline auto generate_filename(const topology_type& top,
                       const uintmax_t dimensions,
                       const uintmax_t number_of_simplices,
                       const uintmax_t number_of_timeslices) noexcept {
  std::string filename;
  if (top == topology_type::SPHERICAL) {
    filename += "S";
  } else {
    filename += "T";
  }
  // std::to_string() works in C++11, but not earlier
  filename += std::to_string(dimensions);

  filename += "-";

  filename += std::to_string(number_of_timeslices);

  filename += "-";

  filename += std::to_string(number_of_simplices);

  // Get user
  filename += "-";
  filename += getEnvVar("USER");

  // Get machine name
  filename += "@";
  filename += hostname();

  // Append current time
  filename += "-";
  filename += currentDateTime();

  // Append .dat file extension
  filename += ".dat";
  return filename;
}

/// @brief Print out runtime results
///
/// This function prints out vertices, edges, facets (2D), and cells (3D).
///
/// @param[in] universe_ptr A std::unique_ptr to a triangulation
template <typename T>
void print_results(const T& universe_ptr) noexcept {
  std::cout << universe_ptr->number_of_vertices()
            << " vertices and "
            << universe_ptr->number_of_finite_edges()
            << " edges and "
            << universe_ptr->number_of_finite_facets()
            << " faces\n"
            << "and "
            << universe_ptr->number_of_finite_cells()
            << " cells." << std::endl;
}

/// @brief Print out runtime results including time elapsed
///
/// This function prints out vertices, edges, facets (2D), cells (3D)
/// and running time on a Triangulation. This calls a simpler version
/// without a timer object.
///
/// @param[in] universe_ptr A std::unique_ptr to a triangulation
/// @param[in] timer A CGAL::Timer object used to determine elapsed time
template <typename T1, typename T2>
void print_results(const T1& universe_ptr, const T2& timer) noexcept {
  print_results(universe_ptr);

  // Display program running time
  std::cout << "Running time is "
            << timer.time()
            << " seconds."
            << std::endl;
}

/// @brief Writes the runtime results to a file
///
/// This function writes the Delaunay triangulation to a file.
/// The filename is generated by the **generate_filename()** function.
/// Provides strong exception-safety.
///
/// @param[in] universe_ptr A std::unique_ptr to a triangulation
/// @param[in] topology The topology type from the scoped enum topology_type
/// @param[in] dimensions The number of dimensions of the triangulation
/// @param[in] number_of_simplices The number of simplices in the triangulation
/// @param[in] number_of_timeslices The number of foliated timeslices
template <typename T>
void write_file(const T& universe_ptr,
                const topology_type& topology,
                const uintmax_t dimensions,
                const uintmax_t number_of_simplices,
                const uintmax_t number_of_timeslices) {
  // mutex to protect file access across threads
  static std::mutex mutex;

  std::string filename = "";
  filename.assign(generate_filename(topology,
                                    dimensions,
                                    number_of_simplices,
                                    number_of_timeslices));
  std::cout << "Writing to file "
            << filename
            << std::endl;

  std::lock_guard<std::mutex> lock(mutex);

  std::ofstream file(filename, std::ios::out);
  if (!file.is_open())
    throw std::runtime_error("Unable to open file.");

  file << *universe_ptr;
}

/// @brief Generate random uintmax_t integers
///
/// This function generates a random uintmax_t integer from [1, max_value]
/// using a non-deterministic random number generator, if supported. There
/// may be exceptions thrown if a random device is not available. See:
/// http://www.cplusplus.com/reference/random/random_device/
/// for more details.
///
/// @param[in] min_value  The minimum value in the range
/// @param[in] max_value  The maximum value in the range
/// @returns A random uintmax_t value between min_value and max_value, inclusive
inline auto generate_random_unsigned(const uintmax_t min_value,
                              const uintmax_t max_value) noexcept {
  // Non-deterministic random number generator
  std::random_device generator;
  std::uniform_int_distribution<int> distribution(min_value, max_value);

  auto result = distribution(generator);

  #ifndef NDEBUG
  std::cout << "Random uintmax_t number is " << result << std::endl;
  #endif

  return result;
}  // generate_random_unsigned()

/// @brief Generate a random timeslice
///
/// This function generates a random timeslice
/// using **generate_random_unsigned()**. Timeslices go from
/// 1 to max_timeslice.
///
/// @param[in] max_timeslice  The maximum timeslice
/// @returns A random timeslice from 1 to max_timeslice
inline auto generate_random_timeslice(uintmax_t const max_timeslice) noexcept {
  return generate_random_unsigned(1, max_timeslice);
}  // generate_random_timeslice()

/// @brief Generate random real numbers
///
/// This function generates a random real number from [min_value, max_value]
/// using a non-deterministic random number generator, if supported. There
/// may be exceptions thrown if a random device is not available. See:
/// http://www.cplusplus.com/reference/random/random_device/
/// for more details.
///
/// @param[in] min_value  The minimum value in the range
/// @param[in] max_value  The maximum value in the range
/// @returns A random real number between min_value and max_value, inclusive
template <typename T>
auto generate_random_real(const T min_value,
                            const T max_value) noexcept {
  std::random_device generator;
  std::uniform_real_distribution<T> distribution(min_value, max_value);

  auto result = distribution(generator);

  #ifndef NDEBUG
  std::cout << "Random trial is " << result << std::endl;
  #endif

  return result;
}

/// @brief Generate a random timeslice
///
/// This function generates a probability
/// using **generate_random_real()**.
///
/// @returns A probability from 0 to 1
inline
auto generate_probability() noexcept {
  auto min = static_cast<long double>(0.0);
  auto max = static_cast<long double>(1.0);
  return generate_random_real(min, max);
}  // generate_probability()

/// @brief Calculate expected # of points per simplex
///
/// Usually, there are less vertices than simplices.
/// Here, we throw away a number of simplices that aren't correctly
/// foliated.
/// The exact formula is given by Dwyer:
/// http://link.springer.com/article/10.1007/BF02574694
///
/// @param[in] dimension  Number of dimensions
/// @param[in] simplices  Number of desired simplices
/// @param[in] timeslices Number of desired timeslices
/// @param[in] output     Prints desired number of simplices on timeslices
/// @returns  The number of points per timeslice to obtain
/// the desired number of simplices
inline
auto expected_points_per_simplex(const uintmax_t dimension,
                                 const uintmax_t simplices,
                                 const uintmax_t timeslices,
                                 const bool output = true)
                                 noexcept {
  if (output) {
    std::cout << simplices << " simplices desired on "
              << timeslices << " timeslices."
              << std::endl;
  }

  const auto simplices_per_timeslice = simplices/timeslices;
  // Avoid segfaults for small values
  if (simplices == timeslices) {
    return 4*simplices_per_timeslice;
  } else if (simplices < 10000) {
    return simplices_per_timeslice;
  } else if (simplices < 100000) {
    return static_cast<uintmax_t>(1.5*simplices_per_timeslice);
  } else {
    return static_cast<uintmax_t>(2.7*simplices_per_timeslice);
  }
}

/// @brief Convert Gmpzf into a double
///
/// This function is mainly for testing, since to_double()
/// seems to work. However, if something more elaborate is required
/// this function can be expanded.
///
/// @param[in] value An exact Gmpzf multiple-precision floating point number
/// @returns The double version
inline
auto Gmpzf_to_double(Gmpzf value) {
  return value.to_double();
}

#endif  // SRC_UTILITIES_H_
